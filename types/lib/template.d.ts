export class Template<Source extends string, Start extends string = "{", End extends string = "}"> extends String {
    static readonly DEFAULT_START_TAG: "{";
    static readonly DEFAULT_END_TAG: "}";
    static create<Source_2 extends string, Start_1 extends string = "{", End_1 extends string = "}", T extends Template<Source_2, Start_1, End_1> = Template<Source_2, Start_1, End_1>>(source: Source_2, tags?: [Start_1, End_1] | undefined, defaults?: CustomPartial<T["replacements"]> | undefined): Template<Source_2, Start_1, End_1>;
    static getPlaceholderPattern(start: string, end: string): RegExp;
    static fromTemplate<T_1 extends AnyTemplate, R_1 extends CustomPartial<T_1["replacements"]>, Source_3 extends string = ApplyReplacements<T_1, R_1, UnionToTuple<keyof R_1, []>, T_1["source"]>>(template: T_1, replacements: R_1): Template<Source_3, T_1["startTag"], T_1["endTag"]>;
    constructor(source: Source, tags?: [Start, End] | undefined, defaults?: CustomPartial<Expand<Record<Extract<Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>[keyof Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>], string>, is.DefinedPrimitive>>> | undefined);
    source: Source;
    startTag: Start;
    endTag: End;
    pattern: RegExp;
    placeholders: [...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>];
    placeholdersMap: Readonly<Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>>;
    replacements: Expand<Record<Extract<Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>[keyof Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>], string>, is.DefinedPrimitive>>;
    render(replacements?: CustomPartial<Expand<Record<Extract<Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>[keyof Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>], string>, is.DefinedPrimitive>>> | undefined, validate?: boolean | undefined): string;
    fork<R extends CustomPartial<Expand<Record<Extract<Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>[keyof Expand<GetPlaceholderMapHelper<[...GetPlaceholdersHelper<string.Clean<Source>, Start, End, []>], Start, End>>], string>, is.DefinedPrimitive>>>, Source_1 extends string = ApplyReplacements<this, R, UnionToTuple<keyof R, []>, this["source"]>>(replacements: R): Template<Source_1, Start, End>;
    validate(value: string): void;
    getRemainingPlaceholders(value: string): string[];
    valueOf(): Source & string;
    #private;
}
export type DefaultStartTag = "{";
export type DefaultEndTag = "}";
export type TemplateReplacements<T extends AnyTemplate> = T["replacements"];
export type PartialTemplateReplacements<T extends AnyTemplate> = Partial<T["replacements"]>;
export type IsValidPlaceholderName<T extends string, S extends string, E extends string> = T extends `${S}${infer W}${E}` ? W extends `${string} ${string}` ? false : string.GetFirstChar<W> extends string.GetFirstChar<S> ? false : string.GetLastChar<W> extends string.GetFirstChar<E> ? false : W extends string.Wrap<W, "", E> ? false : true : false;
export type GetPlaceholdersHelper<Source extends string, Start extends string, End extends string, Cache extends string[] = []> = Source extends "" ? Cache : Source extends `${string}${Start} ${infer N}${infer R}` ? GetPlaceholdersHelper<R, Start, End, Cache> : Source extends `${string}${Start}${infer N_1}${End}${infer R_1}` ? IsValidPlaceholderName<string.Wrap<N_1, Start, End>, Start, End> extends false ? GetPlaceholdersHelper<R_1, Start, End, Cache> : string.Wrap<N_1, Start, End> extends Cache[number] ? GetPlaceholdersHelper<R_1, Start, End, Cache> : GetPlaceholdersHelper<Source, Start, End, [...Cache, string.Wrap<N_1, Start, End>]> : Cache;
export type GetPlaceholders<Source extends string, Start extends string, End extends string> = [...GetPlaceholdersHelper<Source, Start, End>];
export type GetPlaceholderMapHelper<P extends string[], S extends string, E extends string> = { [K in P[number]]: string.Unwrap<K, S, E>; };
export type GetPlaceholderMap<P extends string[], S extends string, E extends string> = Expand<GetPlaceholderMapHelper<P, S, E> & {}>;
export type GetPropertyToPlaceholder<P extends Record<string, string>> = { [K in keyof P as P[K]]: K; };
export type GetReplacements<K extends PropertyKey> = Expand<Record<K, is.DefinedPrimitive>>;
export type CustomPartial<T> = { [K in keyof T]?: T[K] | undefined; };
export type Expand<T> = T extends infer O ? { [K in keyof O]: O[K]; } : T;
export type AnyTemplate = Template<string, any, any>;
export type ApplyReplacements<T extends AnyTemplate, R extends CustomPartial<T["replacements"]>, ToReplace extends unknown = UnionToTuple<keyof R, []>, Result extends string = T["source"]> = ToReplace extends [] ? Result : ToReplace extends [infer F, ...infer Rest] ? F extends keyof R ? R[F] extends is.Nullable ? ApplyReplacements<T, R, Rest, Result> : ApplyReplacements<T, R, Rest, string.ReplaceAll<Result, string.Wrap<F, T["startTag"], T["endTag"]>, string>> : never : R;
export type GetKeys<T extends unknown> = UnionToTuple<keyof T>;
export type UnionToIntersection<T extends unknown> = (T extends T ? (params: T) => any : never) extends (params: infer P) => any ? P : never;
export type UnionToTuple<T extends unknown, Res extends any[] = []> = UnionToIntersection<T extends any ? () => T : never> extends () => infer ReturnType_1 ? UnionToTuple<Exclude<T, ReturnType_1>, [...Res, ReturnType_1]> : Res;
import * as string from "./string.js";
import * as is from "./is.js";
